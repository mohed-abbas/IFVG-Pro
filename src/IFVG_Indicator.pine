// ╔══════════════════════════════════════════════════════════════════╗
// ║                     IFVG INDICATOR v3.0                          ║
// ║                     Phase 3: Multi-Timeframe                     ║
// ║                                                                  ║
// ║  Created: 2026-01-20                                             ║
// ║  Based on DodgysDD IFVG Strategy                                 ║
// ║                                                                  ║
// ║  Phase 1 Features:                                               ║
// ║  - FVG Detection (current timeframe)                             ║
// ║  - IFVG Inversion Detection                                      ║
// ║  - Basic visualization (boxes)                                   ║
// ║  - Mitigation tracking                                           ║
// ║                                                                  ║
// ║  Phase 2 Features:                                               ║
// ║  - Swing structure liquidity detection (EQH, EQL, ITH, ITL)      ║
// ║  - Full grading algorithm (A+ to C)                              ║
// ║  - BE point tracking and validation                              ║
// ║  - Entry valid/invalid status                                    ║
// ║  - Stop loss calculation                                         ║
// ║  - Liquidity sweep detection                                     ║
// ║                                                                  ║
// ║  Phase 3 Features:                                               ║
// ║  - HTF FVG/IFVG detection via request.security                   ║
// ║  - HTF overlay projection on LTF chart                           ║
// ║  - HTF bias determination                                        ║
// ║  - LTF setup filtering based on HTF bias                         ║
// ╚══════════════════════════════════════════════════════════════════╝

//@version=6
indicator("IFVG Indicator", shorttitle="IFVG", overlay=true,
          max_bars_back=500,
          max_boxes_count=500,
          max_lines_count=500,
          max_labels_count=500)

// ══════════════════════════════════════════════════════════════════════
// SECTION 1: TYPE DEFINITIONS
// ══════════════════════════════════════════════════════════════════════

// FVG Status Enum (using strings for clarity)
// "active"    - FVG detected, not yet inverted
// "inverted"  - FVG has been inverted (candle body closed through)
// "mitigated" - Price has fully closed through the inverted zone

// Type: Fair Value Gap
type FVG
    float top           // Upper boundary of gap
    float bottom        // Lower boundary of gap
    float mid           // Midpoint
    int start_bar       // Bar index where FVG starts (candle 1 of 3)
    int end_bar         // Bar index where FVG ends (candle 3 of 3)
    bool is_bullish     // true = bullish FVG, false = bearish FVG
    string status       // "active", "inverted", "mitigated"
    string timeframe    // Source timeframe ("" for current)
    box box_id          // Reference to drawn box
    label label_id      // Reference to label

// Type: SwingPoint - For structure-based liquidity detection
type SwingPoint
    float price         // Swing high/low price
    int bar_idx         // Bar index of swing
    bool is_high        // true = swing high, false = swing low
    bool is_internal    // true = internal structure, false = external
    bool is_valid       // Still valid (not broken)

// Type: Liquidity - All liquidity types (Enhanced for proper EQL/EQH)
type Liquidity
    float level         // Price level (average of touches)
    float original_level // First swing's exact price
    string liq_type     // "EQH", "EQL", "ITH", "ITL"
    string quality      // "perfect", "relative" (NEW)
    int bar_idx         // Bar where first swing formed
    int last_touch_bar  // Bar of most recent valid touch
    int touch_count     // Number of valid touches
    bool is_swept       // true if liquidity has been taken
    int swept_bar       // Bar index where sweep occurred
    bool is_valid       // Still valid for new touches (not broken through)
    line line_id        // Reference to drawn line
    label label_id      // Reference to label

// Type: Inverted Fair Value Gap (Extended for Phase 2)
type IFVG
    float top           // Upper boundary (inherited from source FVG)
    float bottom        // Lower boundary (inherited from source FVG)
    float mid           // Midpoint
    int start_bar       // Original FVG start bar
    int inversion_bar   // Bar where inversion occurred
    float inversion_close  // Close price of inversion candle
    bool is_bullish     // Direction (INVERTED from original FVG)
    string status       // "inverted", "mitigated"
    string grade        // "A+", "A", "A-", "B+", "B", "B-", "C"
    bool entry_valid    // true if SL not yet hit at inversion
    float be_level      // Break-even level (first swing target to the LEFT)
    string be_status    // "intact", "taken"
    float sl_level      // Stop loss level (swing or FVG boundary)
    string sl_type      // "swing" or "fvg_boundary"
    Liquidity dol       // Draw on Liquidity (target)
    bool has_sweep      // Liquidity sweep present
    bool has_delivery   // Delivery from another FVG
    string momentum     // "strong_no_chop", "neutral", "weak_or_choppy"
    box box_id          // Reference to drawn box
    label label_id      // Reference to IFVG label (tiny "IFVG" text)
    line be_line_id     // Reference to BE line
    line sl_line_id     // Reference to SL line
    line entry_line_id  // Reference to entry line (at inversion close)
    label entry_label_id // Reference to entry line label (grade + direction)

// ══════════════════════════════════════════════════════════════════════
// SECTION 2: INPUT CONFIGURATION
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// General Settings
// ─────────────────────────────────────────────────────────────────────
string GROUP_GENERAL = "═══ General Settings ═══"
i_show_indicator    = input.bool(true, "Enable Indicator", group=GROUP_GENERAL)
i_max_fvgs          = input.int(20, "Max Active FVGs to Track", minval=5, maxval=50, group=GROUP_GENERAL,
                      tooltip="Maximum number of active (non-inverted) FVGs to keep in memory")
i_max_ifvgs         = input.int(30, "Max IFVGs to Track", minval=10, maxval=100, group=GROUP_GENERAL,
                      tooltip="Maximum number of IFVG setups to keep in memory. Independent of FVG limit.")
i_max_recent_display = input.int(5, "Max Recent IFVGs to Show", minval=1, maxval=20, group=GROUP_GENERAL,
                      tooltip="Only display the most recent N IFVG setups on chart (visual filter). Does not affect tracking.")
i_extend_bars       = input.int(50, "Extend Boxes (bars)", minval=10, maxval=200, group=GROUP_GENERAL,
                      tooltip="How many bars into the future to extend FVG boxes")

// ─────────────────────────────────────────────────────────────────────
// FVG Detection Settings
// ─────────────────────────────────────────────────────────────────────
string GROUP_FVG = "═══ FVG Detection ═══"
i_fvg_atr_period    = input.int(14, "ATR Period", minval=5, maxval=50, group=GROUP_FVG,
                      tooltip="ATR period used for minimum gap size calculation")
i_fvg_min_size_mult = input.float(0.25, "Min Gap Size (ATR Multiple)", minval=0.05, maxval=1.0,
                      step=0.05, group=GROUP_FVG,
                      tooltip="Minimum FVG size as a multiple of ATR. Lower = more sensitive")
i_show_active_fvg   = input.bool(true, "Show Active FVGs", group=GROUP_FVG,
                      tooltip="Display FVGs that haven't been inverted yet")
i_show_ifvg         = input.bool(true, "Show Inverted FVGs (IFVG)", group=GROUP_FVG,
                      tooltip="Display FVGs that have been inverted")

// ─────────────────────────────────────────────────────────────────────
// Higher Timeframe Settings (Phase 3)
// ─────────────────────────────────────────────────────────────────────
string GROUP_HTF = "═══ Higher Timeframe (HTF) ═══"
i_enable_htf        = input.bool(true, "Enable HTF Analysis", group=GROUP_HTF,
                      tooltip="Enable higher timeframe FVG/IFVG detection for bias")
i_htf_timeframe     = input.timeframe("60", "HTF Timeframe", group=GROUP_HTF,
                      tooltip="Higher timeframe for bias determination (e.g., 60 = 1H)")
i_htf_timeframe_2   = input.timeframe("240", "HTF Timeframe 2 (Optional)", group=GROUP_HTF,
                      tooltip="Second higher timeframe (e.g., 240 = 4H). Leave same as HTF1 to disable")
i_show_htf_fvg      = input.bool(true, "Show HTF FVGs", group=GROUP_HTF,
                      tooltip="Display HTF FVG boxes on chart")
i_show_htf_ifvg     = input.bool(true, "Show HTF IFVGs", group=GROUP_HTF,
                      tooltip="Display HTF IFVG boxes on chart")
i_htf_filter_ltf    = input.bool(true, "Filter LTF by HTF Bias", group=GROUP_HTF,
                      tooltip="Only show LTF setups that align with HTF bias direction")
i_htf_box_opacity   = input.int(75, "HTF Box Opacity (%)", minval=50, maxval=95, group=GROUP_HTF,
                      tooltip="Transparency for HTF boxes. Higher = more transparent")
i_htf_border_width  = input.int(3, "HTF Border Width", minval=1, maxval=5, group=GROUP_HTF,
                      tooltip="Thicker borders to distinguish HTF from LTF")

// ─────────────────────────────────────────────────────────────────────
// Liquidity Detection Settings (Phase 2)
// ─────────────────────────────────────────────────────────────────────
string GROUP_LIQ = "═══ Liquidity Detection ═══"
i_swing_lookback    = input.int(5, "Swing Lookback", minval=3, maxval=10, group=GROUP_LIQ,
                      tooltip="Number of bars to look left/right for swing detection")
i_show_ith_itl      = input.bool(true, "Show ITH/ITL", group=GROUP_LIQ,
                      tooltip="Display Internal Highs and Internal Lows")
i_max_liquidity     = input.int(30, "Max Liquidity Levels", minval=10, maxval=100, group=GROUP_LIQ,
                      tooltip="Maximum liquidity levels to track")

// ─────────────────────────────────────────────────────────────────────
// EQH/EQL Detection Settings (Enhanced)
// ─────────────────────────────────────────────────────────────────────
string GROUP_EQHL = "═══ EQH/EQL Detection ═══"
i_show_eqh_eql      = input.bool(true, "Show EQH/EQL", group=GROUP_EQHL,
                      tooltip="Display Equal Highs and Equal Lows")
i_perfect_tolerance = input.float(0.02, "Perfect EQL/EQH Tolerance (ATR)",
                      minval=0.01, maxval=0.05, step=0.01, group=GROUP_EQHL,
                      tooltip="Swings within this range are 'Perfect' EQL/EQH (★)")
i_relative_tolerance = input.float(0.10, "Relative EQL/EQH Tolerance (ATR)",
                       minval=0.05, maxval=0.25, step=0.01, group=GROUP_EQHL,
                       tooltip="Swings within this range are 'Relative' EQL/EQH (~)")
i_require_intact    = input.bool(true, "Require Intact Liquidity", group=GROUP_EQHL,
                      tooltip="Only form EQL/EQH if price hasn't broken through yet")
i_show_perfect_only = input.bool(false, "Show Perfect EQL/EQH Only", group=GROUP_EQHL,
                      tooltip="Hide relative EQL/EQH, only show perfect matches")
i_show_swept_eqhl   = input.bool(false, "Show Mitigated EQL/EQH", group=GROUP_EQHL,
                      tooltip="Keep displaying EQL/EQH after they're mitigated (swept or broken through)")

// ─────────────────────────────────────────────────────────────────────
// Grading Settings (Phase 2)
// ─────────────────────────────────────────────────────────────────────
string GROUP_GRADE = "═══ Grading Settings ═══"
i_min_grade_display = input.string("B-", "Min Grade to Display",
                      options=["A+", "A", "A-", "B+", "B", "B-", "C", "All"], group=GROUP_GRADE,
                      tooltip="Only show IFVGs with this grade or better")
i_show_be_level     = input.bool(true, "Show BE Levels", group=GROUP_GRADE,
                      tooltip="Display Break-Even point lines (first swing target)")
i_show_sl_level     = input.bool(true, "Show SL Levels", group=GROUP_GRADE,
                      tooltip="Display Stop Loss level lines")
i_sl_type           = input.string("FVG Boundary", "Stop Loss Type",
                      options=["FVG Boundary", "Swing Stop"], group=GROUP_GRADE,
                      tooltip="FVG Boundary: SL at FVG edge. Swing Stop: SL at swing high/low before FVG")
i_show_grade_label  = input.bool(true, "Show Grade on Label", group=GROUP_GRADE,
                      tooltip="Include grade in IFVG label")

// ─────────────────────────────────────────────────────────────────────
// Visual Settings
// ─────────────────────────────────────────────────────────────────────
string GROUP_VISUAL = "═══ Visual Settings ═══"
i_bullish_color     = input.color(color.new(#089981, 0), "Bullish Color", group=GROUP_VISUAL)
i_bearish_color     = input.color(color.new(#F23645, 0), "Bearish Color", group=GROUP_VISUAL)
i_fvg_opacity       = input.int(85, "FVG Opacity (%)", minval=50, maxval=95, group=GROUP_VISUAL,
                      tooltip="Higher = more transparent. Active FVGs use this opacity")
i_show_labels       = input.bool(true, "Show Labels", group=GROUP_VISUAL)
i_label_size        = input.string("small", "Label Size", options=["tiny", "small", "normal"], group=GROUP_VISUAL)
i_liq_color         = input.color(color.orange, "Liquidity Color", group=GROUP_VISUAL,
                      tooltip="Color for liquidity lines (EQH/EQL)")
i_ithl_color        = input.color(color.yellow, "ITH/ITL Color", group=GROUP_VISUAL,
                      tooltip="Color for internal high/low lines")
i_be_color          = input.color(color.white, "BE Level Color", group=GROUP_VISUAL,
                      tooltip="Color for break-even level line")
i_sl_color          = input.color(color.red, "SL Level Color", group=GROUP_VISUAL,
                      tooltip="Color for stop loss level line")

// ─────────────────────────────────────────────────────────────────────
// IFVG Box & Entry Line Settings
// ─────────────────────────────────────────────────────────────────────
string GROUP_IFVG_STYLE = "═══ IFVG Style Settings ═══"
i_ifvg_box_color    = input.color(color.gray, "IFVG Box Color", group=GROUP_IFVG_STYLE,
                      tooltip="Fill color for IFVG boxes (translucent gray recommended)")
i_ifvg_box_opacity  = input.int(60, "IFVG Box Opacity (%)", minval=40, maxval=80, group=GROUP_IFVG_STYLE,
                      tooltip="Transparency level for IFVG boxes. Higher = more transparent")
i_show_entry_line   = input.bool(true, "Show Entry Line", group=GROUP_IFVG_STYLE,
                      tooltip="Display entry line at inversion candle close")
i_entry_color_bull  = input.color(color.new(#2962FF, 0), "Entry Line Color (Bullish)", group=GROUP_IFVG_STYLE,
                      tooltip="Color for bullish IFVG entry line (blue)")
i_entry_color_bear  = input.color(color.new(#F23645, 0), "Entry Line Color (Bearish)", group=GROUP_IFVG_STYLE,
                      tooltip="Color for bearish IFVG entry line (red)")

// ─────────────────────────────────────────────────────────────────────
// Border Settings
// ─────────────────────────────────────────────────────────────────────
string GROUP_BORDER = "═══ Border Settings ═══"
i_fvg_border_width  = input.int(1, "FVG Border Width", minval=1, maxval=4, group=GROUP_BORDER)
i_ifvg_border_width = input.int(2, "IFVG Border Width", minval=1, maxval=4, group=GROUP_BORDER)
i_fvg_border_style  = input.string("Solid", "FVG Border Style", options=["Solid", "Dashed", "Dotted"], group=GROUP_BORDER)
i_ifvg_border_style = input.string("Dashed", "IFVG Border Style", options=["Solid", "Dashed", "Dotted"], group=GROUP_BORDER)

// ══════════════════════════════════════════════════════════════════════
// SECTION 3: GLOBAL VARIABLES & DATA STORES
// ══════════════════════════════════════════════════════════════════════

// FVG Arrays (LTF - current timeframe)
var array<FVG> g_fvg_array = array.new<FVG>()
var array<IFVG> g_ifvg_array = array.new<IFVG>()

// HTF FVG Arrays (Phase 3)
var array<FVG> g_htf_fvg_array = array.new<FVG>()
var array<FVG> g_htf2_fvg_array = array.new<FVG>()
var array<IFVG> g_htf_ifvg_array = array.new<IFVG>()
var array<IFVG> g_htf2_ifvg_array = array.new<IFVG>()

// Liquidity Arrays (Phase 2)
var array<SwingPoint> g_swing_highs = array.new<SwingPoint>()
var array<SwingPoint> g_swing_lows = array.new<SwingPoint>()
var array<Liquidity> g_liquidity_array = array.new<Liquidity>()

// ATR for sizing
atr_value = ta.atr(i_fvg_atr_period)

// ══════════════════════════════════════════════════════════════════════
// SECTION 4: UTILITY FUNCTIONS
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Get label size from string
// ─────────────────────────────────────────────────────────────────────
get_label_size() =>
    result = size.small
    switch i_label_size
        "tiny"   => result := size.tiny
        "small"  => result := size.small
        "normal" => result := size.normal
    result

// ─────────────────────────────────────────────────────────────────────
// Get color based on direction and status
// ─────────────────────────────────────────────────────────────────────
get_fvg_color(bool is_bullish) =>
    base_color = is_bullish ? i_bullish_color : i_bearish_color
    color.new(base_color, i_fvg_opacity)

get_border_color(bool is_bullish) =>
    is_bullish ? i_bullish_color : i_bearish_color

// ─────────────────────────────────────────────────────────────────────
// Get border style from string input
// ─────────────────────────────────────────────────────────────────────
get_border_style(string style_str) =>
    result = line.style_solid
    switch style_str
        "Solid"  => result := line.style_solid
        "Dashed" => result := line.style_dashed
        "Dotted" => result := line.style_dotted
    result

// ─────────────────────────────────────────────────────────────────────
// Grade to numeric value for comparison
// ─────────────────────────────────────────────────────────────────────
grade_to_value(string grade) =>
    int result = 0
    switch grade
        "A+" => result := 7
        "A"  => result := 6
        "A-" => result := 5
        "B+" => result := 4
        "B"  => result := 3
        "B-" => result := 2
        "C"  => result := 1
    result

// ─────────────────────────────────────────────────────────────────────
// Check if grade meets minimum threshold
// ─────────────────────────────────────────────────────────────────────
grade_meets_minimum(string grade, string min_grade) =>
    if min_grade == "All"
        true
    else
        grade_to_value(grade) >= grade_to_value(min_grade)

// ─────────────────────────────────────────────────────────────────────
// Grade to color for visual distinction
// ─────────────────────────────────────────────────────────────────────
grade_to_color(string grade) =>
    color result = color.gray
    switch grade
        "A+" => result := color.new(#00FF00, 0)  // Bright green
        "A"  => result := color.new(#00CC00, 0)  // Green
        "A-" => result := color.new(#66CC00, 0)  // Yellow-green
        "B+" => result := color.new(#FFCC00, 0)  // Yellow
        "B"  => result := color.new(#FF9900, 0)  // Orange
        "B-" => result := color.new(#FF6600, 0)  // Dark orange
        "C"  => result := color.new(#FF3333, 0)  // Red
    result

// ─────────────────────────────────────────────────────────────────────
// Clean up arrays when they exceed limits
// ─────────────────────────────────────────────────────────────────────
cleanup_fvg_array() =>
    while array.size(g_fvg_array) > i_max_fvgs
        old_fvg = array.shift(g_fvg_array)
        if not na(old_fvg.box_id)
            box.delete(old_fvg.box_id)
        if not na(old_fvg.label_id)
            label.delete(old_fvg.label_id)

cleanup_ifvg_array() =>
    while array.size(g_ifvg_array) > i_max_ifvgs
        old_ifvg = array.shift(g_ifvg_array)
        if not na(old_ifvg.box_id)
            box.delete(old_ifvg.box_id)
        if not na(old_ifvg.label_id)
            label.delete(old_ifvg.label_id)
        if not na(old_ifvg.be_line_id)
            line.delete(old_ifvg.be_line_id)
        if not na(old_ifvg.sl_line_id)
            line.delete(old_ifvg.sl_line_id)
        if not na(old_ifvg.entry_line_id)
            line.delete(old_ifvg.entry_line_id)
        if not na(old_ifvg.entry_label_id)
            label.delete(old_ifvg.entry_label_id)

cleanup_liquidity_array() =>
    while array.size(g_liquidity_array) > i_max_liquidity
        old_liq = array.shift(g_liquidity_array)
        if not na(old_liq.line_id)
            line.delete(old_liq.line_id)
        if not na(old_liq.label_id)
            label.delete(old_liq.label_id)

// ─────────────────────────────────────────────────────────────────────
// Check if a swing level is still intact (not broken through)
// For EQL: returns true if price never CLOSED below the swing low
// For EQH: returns true if price never CLOSED above the swing high
// ─────────────────────────────────────────────────────────────────────
is_swing_intact(float swing_price, bool is_low, int swing_bar) =>
    bool intact = true
    int bars_to_check = bar_index - swing_bar

    // Limit check to prevent performance issues
    int max_check = math.min(bars_to_check, 500)

    if max_check > 0
        for i = 0 to max_check - 1
            if is_low
                // For lows: check if price ever CLOSED below
                if close[i] < swing_price
                    intact := false
                    break
            else
                // For highs: check if price ever CLOSED above
                if close[i] > swing_price
                    intact := false
                    break

    intact

// ─────────────────────────────────────────────────────────────────────
// Classify EQL/EQH quality based on price difference
// ─────────────────────────────────────────────────────────────────────
get_eqhl_quality(float price_diff, float atr) =>
    string quality = "none"

    if not na(atr) and atr > 0
        float perfect_thresh = atr * i_perfect_tolerance
        float relative_thresh = atr * i_relative_tolerance

        if price_diff <= perfect_thresh
            quality := "perfect"
        else if price_diff <= relative_thresh
            quality := "relative"

    quality

// ─────────────────────────────────────────────────────────────────────
// Check if new swing forms valid EQL (must be AT or ABOVE previous)
// ─────────────────────────────────────────────────────────────────────
is_valid_eql_formation(float swing1_low, float swing2_low, float tolerance) =>
    // Swing 2 must be >= Swing 1 (within small tolerance for "exactly equal")
    // This ensures new low is at same level or holding higher (support holding)
    swing2_low >= swing1_low - tolerance

// ─────────────────────────────────────────────────────────────────────
// Check if new swing forms valid EQH (must be AT or BELOW previous)
// ─────────────────────────────────────────────────────────────────────
is_valid_eqh_formation(float swing1_high, float swing2_high, float tolerance) =>
    // Swing 2 must be <= Swing 1 (within small tolerance for "exactly equal")
    // This ensures new high is at same level or failing to break (resistance holding)
    swing2_high <= swing1_high + tolerance

// ─────────────────────────────────────────────────────────────────────
// Check if liquidity was swept between two swing points (WICK-based)
// For EQH: Returns true if any bar's HIGH went above the reference level
// For EQL: Returns true if any bar's LOW went below the reference level
// This includes the second swing bar itself
// ─────────────────────────────────────────────────────────────────────
was_liquidity_swept_between(int bar1_idx, int bar2_idx, float ref_level, bool check_highs) =>
    bool swept = false
    int bars_between = bar_index - bar1_idx  // How many bars back is bar1
    int bars_to_bar2 = bar_index - bar2_idx  // How many bars back is bar2

    // Loop from bar1+1 to bar2 (inclusive of bar2)
    if bars_between > 0 and bars_to_bar2 >= 0
        for offset = bars_between - 1 to bars_to_bar2
            if offset >= 0 and offset < bars_between
                if check_highs
                    // For EQH: check if any HIGH exceeded the reference level
                    if high[offset] > ref_level
                        swept := true
                        break
                else
                    // For EQL: check if any LOW went below the reference level
                    if low[offset] < ref_level
                        swept := true
                        break
    swept

// ══════════════════════════════════════════════════════════════════════
// SECTION 5: FVG DETECTION
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Detect Fair Value Gaps
// ─────────────────────────────────────────────────────────────────────
detect_fvg() =>
    FVG result = na

    if barstate.isconfirmed and not na(atr_value)
        min_gap = atr_value * i_fvg_min_size_mult

        // Bullish FVG: low[0] > high[2]
        bullish_gap_size = low - high[2]
        if bullish_gap_size > min_gap
            result := FVG.new(
                top = low,
                bottom = high[2],
                mid = (low + high[2]) / 2,
                start_bar = bar_index - 2,
                end_bar = bar_index,
                is_bullish = true,
                status = "active",
                timeframe = "",
                box_id = na,
                label_id = na
            )

        // Bearish FVG: high[0] < low[2]
        bearish_gap_size = low[2] - high
        if bearish_gap_size > min_gap and na(result)
            result := FVG.new(
                top = low[2],
                bottom = high,
                mid = (low[2] + high) / 2,
                start_bar = bar_index - 2,
                end_bar = bar_index,
                is_bullish = false,
                status = "active",
                timeframe = "",
                box_id = na,
                label_id = na
            )

    result

// ══════════════════════════════════════════════════════════════════════
// SECTION 5B: HTF FVG DETECTION (Phase 3)
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Get HTF OHLC data via request.security
// ─────────────────────────────────────────────────────────────────────
// HTF 1 Data - Individual requests to avoid tuple issues
htf_high = request.security(syminfo.tickerid, i_htf_timeframe, high, lookahead=barmerge.lookahead_off)
htf_low = request.security(syminfo.tickerid, i_htf_timeframe, low, lookahead=barmerge.lookahead_off)
htf_close = request.security(syminfo.tickerid, i_htf_timeframe, close, lookahead=barmerge.lookahead_off)
htf_high_2 = request.security(syminfo.tickerid, i_htf_timeframe, high[2], lookahead=barmerge.lookahead_off)
htf_low_2 = request.security(syminfo.tickerid, i_htf_timeframe, low[2], lookahead=barmerge.lookahead_off)
htf_bar_idx_raw = request.security(syminfo.tickerid, i_htf_timeframe, bar_index, lookahead=barmerge.lookahead_off)
int htf_bar_idx = int(htf_bar_idx_raw)

// HTF 2 Data
htf2_high = request.security(syminfo.tickerid, i_htf_timeframe_2, high, lookahead=barmerge.lookahead_off)
htf2_low = request.security(syminfo.tickerid, i_htf_timeframe_2, low, lookahead=barmerge.lookahead_off)
htf2_close = request.security(syminfo.tickerid, i_htf_timeframe_2, close, lookahead=barmerge.lookahead_off)
htf2_high_2 = request.security(syminfo.tickerid, i_htf_timeframe_2, high[2], lookahead=barmerge.lookahead_off)
htf2_low_2 = request.security(syminfo.tickerid, i_htf_timeframe_2, low[2], lookahead=barmerge.lookahead_off)
htf2_bar_idx_raw = request.security(syminfo.tickerid, i_htf_timeframe_2, bar_index, lookahead=barmerge.lookahead_off)
int htf2_bar_idx = int(htf2_bar_idx_raw)

// Track HTF bar changes to detect new HTF bars
var int prev_htf_bar = na
var int prev_htf2_bar = na
bool htf_bar_changed = na(prev_htf_bar) or htf_bar_idx != prev_htf_bar
bool htf2_bar_changed = na(prev_htf2_bar) or htf2_bar_idx != prev_htf2_bar
prev_htf_bar := htf_bar_idx
prev_htf2_bar := htf2_bar_idx

// HTF ATR for sizing (calculated on HTF)
htf_atr = request.security(syminfo.tickerid, i_htf_timeframe, ta.atr(i_fvg_atr_period), lookahead=barmerge.lookahead_off)
htf2_atr = request.security(syminfo.tickerid, i_htf_timeframe_2, ta.atr(i_fvg_atr_period), lookahead=barmerge.lookahead_off)

// ─────────────────────────────────────────────────────────────────────
// Detect HTF Fair Value Gaps
// ─────────────────────────────────────────────────────────────────────
detect_htf_fvg(string tf, float h, float l, float h2, float l2, float atr_val, bool bar_changed) =>
    FVG result = na

    if i_enable_htf and bar_changed and barstate.isconfirmed and not na(atr_val)
        min_gap = atr_val * i_fvg_min_size_mult

        // Bullish FVG: current low > high[2]
        bullish_gap_size = l - h2
        if bullish_gap_size > min_gap
            result := FVG.new(
                top = l,
                bottom = h2,
                mid = (l + h2) / 2,
                start_bar = bar_index - 2,  // Approximate LTF bar position
                end_bar = bar_index,
                is_bullish = true,
                status = "active",
                timeframe = tf,
                box_id = na,
                label_id = na
            )

        // Bearish FVG: current high < low[2]
        bearish_gap_size = l2 - h
        if bearish_gap_size > min_gap and na(result)
            result := FVG.new(
                top = l2,
                bottom = h,
                mid = (l2 + h) / 2,
                start_bar = bar_index - 2,
                end_bar = bar_index,
                is_bullish = false,
                status = "active",
                timeframe = tf,
                box_id = na,
                label_id = na
            )

    result

// ─────────────────────────────────────────────────────────────────────
// Check if HTF FVG already exists (avoid duplicates)
// ─────────────────────────────────────────────────────────────────────
htf_fvg_exists(array<FVG> arr, float top, float bottom, bool is_bullish) =>
    bool exists = false
    int arr_size = array.size(arr)
    if arr_size > 0
        for i = 0 to arr_size - 1
            fvg = array.get(arr, i)
            // Check if same zone (with small tolerance)
            float tolerance = atr_value * 0.1
            if fvg.is_bullish == is_bullish and
               math.abs(fvg.top - top) < tolerance and
               math.abs(fvg.bottom - bottom) < tolerance
                exists := true
                break
    exists

// ─────────────────────────────────────────────────────────────────────
// Cleanup HTF arrays
// ─────────────────────────────────────────────────────────────────────
cleanup_htf_fvg_array(array<FVG> arr, int max_count) =>
    while array.size(arr) > max_count
        old_fvg = array.shift(arr)
        if not na(old_fvg.box_id)
            box.delete(old_fvg.box_id)
        if not na(old_fvg.label_id)
            label.delete(old_fvg.label_id)

cleanup_htf_ifvg_array(array<IFVG> arr, int max_count) =>
    while array.size(arr) > max_count
        old_ifvg = array.shift(arr)
        if not na(old_ifvg.box_id)
            box.delete(old_ifvg.box_id)
        if not na(old_ifvg.label_id)
            label.delete(old_ifvg.label_id)

// ─────────────────────────────────────────────────────────────────────
// Check HTF FVG inversions (simplified - no full grading)
// ─────────────────────────────────────────────────────────────────────
check_htf_inversions(array<FVG> fvg_arr, array<IFVG> ifvg_arr, float htf_c, string tf) =>
    int fvg_size = array.size(fvg_arr)
    if barstate.isconfirmed and fvg_size > 0 and not na(htf_c)
        for i = fvg_size - 1 to 0
            if i >= 0 and i < array.size(fvg_arr)
                fvg = array.get(fvg_arr, i)

                if fvg.status == "active"
                    fvg_age = bar_index - fvg.end_bar

                    if fvg_age >= 1
                        bool inverted = false

                        // Bullish FVG Inversion: body closes below
                        if fvg.is_bullish
                            if htf_c < fvg.bottom
                                inverted := true

                        // Bearish FVG Inversion: body closes above
                        else
                            if htf_c > fvg.top
                                inverted := true

                        if inverted
                            fvg.status := "inverted"

                            // Delete FVG drawings
                            if not na(fvg.box_id)
                                box.delete(fvg.box_id)
                            if not na(fvg.label_id)
                                label.delete(fvg.label_id)

                            // IFVG direction is INVERTED from FVG
                            bool ifvg_is_bullish = not fvg.is_bullish

                            // Create simplified HTF IFVG (no grading needed for bias)
                            new_ifvg = IFVG.new(
                                top = fvg.top,
                                bottom = fvg.bottom,
                                mid = fvg.mid,
                                start_bar = fvg.start_bar,
                                inversion_bar = bar_index,
                                inversion_close = htf_c,
                                is_bullish = ifvg_is_bullish,
                                status = "inverted",
                                grade = "HTF",  // Mark as HTF
                                entry_valid = true,
                                be_level = ifvg_is_bullish ? fvg.top : fvg.bottom,
                                be_status = "intact",
                                sl_level = ifvg_is_bullish ? fvg.bottom : fvg.top,
                                sl_type = "fvg_boundary",
                                dol = na,
                                has_sweep = false,
                                has_delivery = false,
                                momentum = "neutral",
                                box_id = na,
                                label_id = na,
                                be_line_id = na,
                                sl_line_id = na,
                                entry_line_id = na,
                                entry_label_id = na
                            )

                            array.push(ifvg_arr, new_ifvg)

                            // Remove from FVG array
                            array.remove(fvg_arr, i)

// ─────────────────────────────────────────────────────────────────────
// Check HTF IFVG mitigation
// ─────────────────────────────────────────────────────────────────────
check_htf_mitigations(array<IFVG> ifvg_arr, float htf_c) =>
    int ifvg_size = array.size(ifvg_arr)
    if barstate.isconfirmed and ifvg_size > 0 and not na(htf_c)
        for i = ifvg_size - 1 to 0
            if i >= 0 and i < array.size(ifvg_arr)
                ifvg = array.get(ifvg_arr, i)

                if ifvg.status == "inverted"
                    bool mitigated = false

                    // Bullish IFVG mitigated: price closes below zone
                    if ifvg.is_bullish
                        if htf_c < ifvg.bottom
                            mitigated := true

                    // Bearish IFVG mitigated: price closes above zone
                    else
                        if htf_c > ifvg.top
                            mitigated := true

                    if mitigated
                        // Delete drawings
                        if not na(ifvg.box_id)
                            box.delete(ifvg.box_id)
                        if not na(ifvg.label_id)
                            label.delete(ifvg.label_id)

                        array.remove(ifvg_arr, i)

// ══════════════════════════════════════════════════════════════════════
// SECTION 6: SWING POINT & LIQUIDITY DETECTION (Phase 2)
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Detect swing highs and lows
// ─────────────────────────────────────────────────────────────────────
detect_swing_points() =>
    if barstate.isconfirmed
        lookback = i_swing_lookback

        // Check if we have enough bars
        if bar_index > lookback * 2
            // Detect swing high at [lookback] position
            bool is_swing_high = true
            float pivot_high = high[lookback]

            for j = 1 to lookback
                if high[lookback] <= high[lookback - j] or high[lookback] <= high[lookback + j]
                    is_swing_high := false
                    break

            if is_swing_high
                // Create swing high
                new_swing = SwingPoint.new(
                    price = pivot_high,
                    bar_idx = bar_index - lookback,
                    is_high = true,
                    is_internal = false,  // Will be determined later
                    is_valid = true
                )
                array.push(g_swing_highs, new_swing)

                // Limit array size
                if array.size(g_swing_highs) > 50
                    array.shift(g_swing_highs)

            // Detect swing low at [lookback] position
            bool is_swing_low = true
            float pivot_low = low[lookback]

            for j = 1 to lookback
                if low[lookback] >= low[lookback - j] or low[lookback] >= low[lookback + j]
                    is_swing_low := false
                    break

            if is_swing_low
                // Create swing low
                new_swing = SwingPoint.new(
                    price = pivot_low,
                    bar_idx = bar_index - lookback,
                    is_high = false,
                    is_internal = false,
                    is_valid = true
                )
                array.push(g_swing_lows, new_swing)

                // Limit array size
                if array.size(g_swing_lows) > 50
                    array.shift(g_swing_lows)

// ─────────────────────────────────────────────────────────────────────
// Check for Equal Highs (EQH) - REDESIGNED
// Rules:
//   1. Both swings must form BEFORE price breaks above either
//   2. New swing must be AT or BELOW previous swing (resistance holding)
//   3. Quality: "perfect" if within 0.02 ATR, "relative" if within 0.1 ATR
// ─────────────────────────────────────────────────────────────────────
check_equal_highs() =>
    int swing_size = array.size(g_swing_highs)
    if swing_size >= 2 and not na(atr_value)
        float relative_tol = atr_value * i_relative_tolerance

        // Get the most recent swing high
        recent_high = array.get(g_swing_highs, swing_size - 1)

        // RULE 1: Check if recent swing is still intact (not broken through)
        bool recent_intact = true
        if i_require_intact
            recent_intact := is_swing_intact(recent_high.price, false, recent_high.bar_idx)

        if recent_intact
            // Check against previous swing highs for EQH
            int start_idx = swing_size - 2
            int end_idx = math.max(0, swing_size - 10)

            for i = start_idx to end_idx
                if i >= 0 and i < swing_size
                    prev_high = array.get(g_swing_highs, i)

                    // RULE 1: Previous swing must also be intact
                    bool prev_intact = true
                    if i_require_intact
                        prev_intact := is_swing_intact(prev_high.price, false, prev_high.bar_idx)

                    if prev_intact
                        // RULE 2: New swing must be AT or BELOW previous (resistance holding)
                        // For EQH: recent_high.price <= prev_high.price + tolerance
                        if is_valid_eqh_formation(prev_high.price, recent_high.price, relative_tol)
                            // Calculate price difference
                            float price_diff = math.abs(recent_high.price - prev_high.price)

                            // RULE 3: Must be within tolerance
                            if price_diff <= relative_tol
                                // RULE 4 (NEW): Liquidity must NOT have been swept between the swings
                                // Check if any bar's HIGH (wick) went above the first swing's high
                                bool liquidity_swept = was_liquidity_swept_between(prev_high.bar_idx, recent_high.bar_idx, prev_high.price, true)

                                if not liquidity_swept
                                    // Determine quality
                                    string quality = get_eqhl_quality(price_diff, atr_value)

                                    if quality != "none"
                                        // NOTE: i_show_perfect_only is handled in render_liquidity_lines()
                                        // Data must always be collected for grading algorithms to work

                                        // Check if EQH already exists at this level
                                        bool exists = false
                                        int liq_size = array.size(g_liquidity_array)
                                        if liq_size > 0
                                            for j = 0 to liq_size - 1
                                                if j < liq_size
                                                    liq = array.get(g_liquidity_array, j)
                                                    if liq.liq_type == "EQH" and liq.is_valid and not liq.is_swept
                                                        if math.abs(liq.level - recent_high.price) <= relative_tol
                                                            // Update existing EQH with new touch
                                                            liq.touch_count := liq.touch_count + 1
                                                            liq.last_touch_bar := recent_high.bar_idx
                                                            // Upgrade quality if better
                                                            if quality == "perfect" and liq.quality == "relative"
                                                                liq.quality := "perfect"
                                                            exists := true
                                                            break

                                        // Create new EQH if doesn't exist
                                        if not exists
                                            // Use the LOWER of the two highs as the level (more conservative)
                                            float eqh_level = math.min(recent_high.price, prev_high.price)

                                            new_liq = Liquidity.new(
                                                level = eqh_level,
                                                original_level = prev_high.price,
                                                liq_type = "EQH",
                                                quality = quality,
                                                bar_idx = prev_high.bar_idx,
                                                last_touch_bar = recent_high.bar_idx,
                                                touch_count = 2,
                                                is_swept = false,
                                                swept_bar = 0,
                                                is_valid = true,
                                                line_id = na,
                                                label_id = na
                                            )
                                            array.push(g_liquidity_array, new_liq)
                                        break  // Only create one EQH per swing high

// ─────────────────────────────────────────────────────────────────────
// Check for Equal Lows (EQL) - REDESIGNED
// Rules:
//   1. Both swings must form BEFORE price breaks below either
//   2. New swing must be AT or ABOVE previous swing (support holding)
//   3. Quality: "perfect" if within 0.02 ATR, "relative" if within 0.1 ATR
// ─────────────────────────────────────────────────────────────────────
check_equal_lows() =>
    int swing_size = array.size(g_swing_lows)
    if swing_size >= 2 and not na(atr_value)
        float relative_tol = atr_value * i_relative_tolerance

        // Get the most recent swing low
        recent_low = array.get(g_swing_lows, swing_size - 1)

        // RULE 1: Check if recent swing is still intact (not broken through)
        bool recent_intact = true
        if i_require_intact
            recent_intact := is_swing_intact(recent_low.price, true, recent_low.bar_idx)

        if recent_intact
            // Check against previous swing lows for EQL
            int start_idx = swing_size - 2
            int end_idx = math.max(0, swing_size - 10)

            for i = start_idx to end_idx
                if i >= 0 and i < swing_size
                    prev_low = array.get(g_swing_lows, i)

                    // RULE 1: Previous swing must also be intact
                    bool prev_intact = true
                    if i_require_intact
                        prev_intact := is_swing_intact(prev_low.price, true, prev_low.bar_idx)

                    if prev_intact
                        // RULE 2: New swing must be AT or ABOVE previous (support holding)
                        // For EQL: recent_low.price >= prev_low.price - tolerance
                        if is_valid_eql_formation(prev_low.price, recent_low.price, relative_tol)
                            // Calculate price difference
                            float price_diff = math.abs(recent_low.price - prev_low.price)

                            // RULE 3: Must be within tolerance
                            if price_diff <= relative_tol
                                // RULE 4 (NEW): Liquidity must NOT have been swept between the swings
                                // Check if any bar's LOW (wick) went below the first swing's low
                                bool liquidity_swept = was_liquidity_swept_between(prev_low.bar_idx, recent_low.bar_idx, prev_low.price, false)

                                if not liquidity_swept
                                    // Determine quality
                                    string quality = get_eqhl_quality(price_diff, atr_value)

                                    if quality != "none"
                                        // NOTE: i_show_perfect_only is handled in render_liquidity_lines()
                                        // Data must always be collected for grading algorithms to work

                                        // Check if EQL already exists at this level
                                        bool exists = false
                                        int liq_size = array.size(g_liquidity_array)
                                        if liq_size > 0
                                            for j = 0 to liq_size - 1
                                                if j < liq_size
                                                    liq = array.get(g_liquidity_array, j)
                                                    if liq.liq_type == "EQL" and liq.is_valid and not liq.is_swept
                                                        if math.abs(liq.level - recent_low.price) <= relative_tol
                                                            // Update existing EQL with new touch
                                                            liq.touch_count := liq.touch_count + 1
                                                            liq.last_touch_bar := recent_low.bar_idx
                                                            // Upgrade quality if better
                                                            if quality == "perfect" and liq.quality == "relative"
                                                                liq.quality := "perfect"
                                                            exists := true
                                                            break

                                        // Create new EQL if doesn't exist
                                        if not exists
                                            // Use the HIGHER of the two lows as the level (more conservative)
                                            float eql_level = math.max(recent_low.price, prev_low.price)

                                            new_liq = Liquidity.new(
                                                level = eql_level,
                                                original_level = prev_low.price,
                                                liq_type = "EQL",
                                                quality = quality,
                                                bar_idx = prev_low.bar_idx,
                                                last_touch_bar = recent_low.bar_idx,
                                                touch_count = 2,
                                                is_swept = false,
                                                swept_bar = 0,
                                                is_valid = true,
                                                line_id = na,
                                                label_id = na
                                            )
                                            array.push(g_liquidity_array, new_liq)
                                        break  // Only create one EQL per swing low

// ─────────────────────────────────────────────────────────────────────
// Create Internal Highs/Lows (ITH/ITL)
// These are recent swing points that serve as BE references
// ─────────────────────────────────────────────────────────────────────
create_internal_levels() =>
    // Create ITH from recent swing highs
    // NOTE: i_show_ith_itl is handled in render_liquidity_lines()
    // Data must always be collected for grading algorithms to work
    int swing_high_size = array.size(g_swing_highs)
    if swing_high_size > 0
        recent_high = array.get(g_swing_highs, swing_high_size - 1)

        // Check if ITH already exists
        bool ith_exists = false
        int liq_size_1 = array.size(g_liquidity_array)
        if liq_size_1 > 0
            for i = 0 to liq_size_1 - 1
                if i < liq_size_1
                    liq = array.get(g_liquidity_array, i)
                    if liq.liq_type == "ITH" and liq.bar_idx == recent_high.bar_idx
                        ith_exists := true
                        break

        if not ith_exists
            new_ith = Liquidity.new(
                level = recent_high.price,
                original_level = recent_high.price,
                liq_type = "ITH",
                quality = "na",
                bar_idx = recent_high.bar_idx,
                last_touch_bar = recent_high.bar_idx,
                touch_count = 1,
                is_swept = false,
                swept_bar = 0,
                is_valid = true,
                line_id = na,
                label_id = na
            )
            array.push(g_liquidity_array, new_ith)

    // Create ITL from recent swing lows
    // NOTE: i_show_ith_itl is handled in render_liquidity_lines()
    int swing_low_size = array.size(g_swing_lows)
    if swing_low_size > 0
        recent_low = array.get(g_swing_lows, swing_low_size - 1)

        bool itl_exists = false
        int liq_size_2 = array.size(g_liquidity_array)
        if liq_size_2 > 0
            for i = 0 to liq_size_2 - 1
                if i < liq_size_2
                    liq = array.get(g_liquidity_array, i)
                    if liq.liq_type == "ITL" and liq.bar_idx == recent_low.bar_idx
                        itl_exists := true
                        break

        if not itl_exists
            new_itl = Liquidity.new(
                level = recent_low.price,
                original_level = recent_low.price,
                liq_type = "ITL",
                quality = "na",
                bar_idx = recent_low.bar_idx,
                last_touch_bar = recent_low.bar_idx,
                touch_count = 1,
                is_swept = false,
                swept_bar = 0,
                is_valid = true,
                line_id = na,
                label_id = na
            )
            array.push(g_liquidity_array, new_itl)

// ─────────────────────────────────────────────────────────────────────
// Check for liquidity sweeps (Enhanced for EQL/EQH)
// When swept: mark as swept AND invalidate for future touches
// ─────────────────────────────────────────────────────────────────────
check_liquidity_sweeps() =>
    int liq_size = array.size(g_liquidity_array)
    if barstate.isconfirmed and liq_size > 0
        for i = 0 to liq_size - 1
            if i < liq_size
                liq = array.get(g_liquidity_array, i)

                if not liq.is_swept and liq.is_valid
                    // BSL Sweep: high wicks above, close stays below
                    if (liq.liq_type == "EQH" or liq.liq_type == "ITH")
                        if high > liq.level and close < liq.level
                            liq.is_swept := true
                            liq.swept_bar := bar_index
                            liq.is_valid := false  // No more touches count

                    // SSL Sweep: low wicks below, close stays above
                    if (liq.liq_type == "EQL" or liq.liq_type == "ITL")
                        if low < liq.level and close > liq.level
                            liq.is_swept := true
                            liq.swept_bar := bar_index
                            liq.is_valid := false  // No more touches count

                // Also check for complete break (close through) - invalidates without sweep marker
                if liq.is_valid and not liq.is_swept
                    if (liq.liq_type == "EQH" or liq.liq_type == "ITH")
                        if close > liq.level
                            liq.is_valid := false  // Broken through, no longer valid for EQH
                    if (liq.liq_type == "EQL" or liq.liq_type == "ITL")
                        if close < liq.level
                            liq.is_valid := false  // Broken through, no longer valid for EQL

// ══════════════════════════════════════════════════════════════════════
// SECTION 7: BE POINT & GRADING FUNCTIONS (Phase 2)
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Find nearest internal high after a bar index (for bearish IFVG BE)
// ─────────────────────────────────────────────────────────────────────
find_next_internal_high(int after_bar) =>
    float result = na
    int closest_bar = 999999
    int arr_size = array.size(g_swing_highs)

    if arr_size > 0
        for i = 0 to arr_size - 1
            if i < arr_size
                swing = array.get(g_swing_highs, i)
                if swing.bar_idx > after_bar and swing.bar_idx < closest_bar
                    result := swing.price
                    closest_bar := swing.bar_idx

    result

// ─────────────────────────────────────────────────────────────────────
// Find nearest internal low after a bar index (for bullish IFVG BE)
// ─────────────────────────────────────────────────────────────────────
find_next_internal_low(int after_bar) =>
    float result = na
    int closest_bar = 999999
    int arr_size = array.size(g_swing_lows)

    if arr_size > 0
        for i = 0 to arr_size - 1
            if i < arr_size
                swing = array.get(g_swing_lows, i)
                if swing.bar_idx > after_bar and swing.bar_idx < closest_bar
                    result := swing.price
                    closest_bar := swing.bar_idx

    result

// ─────────────────────────────────────────────────────────────────────
// Find nearest swing HIGH BEFORE a bar index (to the LEFT)
// Used for: Bullish IFVG BE point, Bearish IFVG SL (swing stop option)
// ─────────────────────────────────────────────────────────────────────
find_previous_swing_high(int before_bar) =>
    float result = na
    int closest_bar = -1
    int arr_size = array.size(g_swing_highs)

    if arr_size > 0
        for i = arr_size - 1 to 0  // Iterate backwards to find most recent
            if i >= 0 and i < arr_size
                swing = array.get(g_swing_highs, i)
                if swing.bar_idx < before_bar and swing.bar_idx > closest_bar
                    result := swing.price
                    closest_bar := swing.bar_idx

    result

// ─────────────────────────────────────────────────────────────────────
// Find nearest swing LOW BEFORE a bar index (to the LEFT)
// Used for: Bearish IFVG BE point, Bullish IFVG SL (swing stop option)
// ─────────────────────────────────────────────────────────────────────
find_previous_swing_low(int before_bar) =>
    float result = na
    int closest_bar = -1
    int arr_size = array.size(g_swing_lows)

    if arr_size > 0
        for i = arr_size - 1 to 0  // Iterate backwards to find most recent
            if i >= 0 and i < arr_size
                swing = array.get(g_swing_lows, i)
                if swing.bar_idx < before_bar and swing.bar_idx > closest_bar
                    result := swing.price
                    closest_bar := swing.bar_idx

    result

// ─────────────────────────────────────────────────────────────────────
// Find nearest Draw on Liquidity (target)
// For bullish IFVG: find BSL (highs above)
// For bearish IFVG: find SSL (lows below)
// ─────────────────────────────────────────────────────────────────────
find_dol(bool is_bullish_ifvg, float current_price) =>
    Liquidity result = na
    float best_distance = 999999.0
    int arr_size = array.size(g_liquidity_array)

    if arr_size > 0
        for i = 0 to arr_size - 1
            if i < arr_size
                liq = array.get(g_liquidity_array, i)

                // DOL must be both un-swept AND still valid (not broken through)
                if not liq.is_swept and liq.is_valid
                    if is_bullish_ifvg
                        // For bullish IFVG, target BSL (highs above current price)
                        if (liq.liq_type == "EQH" or liq.liq_type == "ITH") and liq.level > current_price
                            distance = liq.level - current_price
                            if distance < best_distance
                                best_distance := distance
                                result := liq
                    else
                        // For bearish IFVG, target SSL (lows below current price)
                        if (liq.liq_type == "EQL" or liq.liq_type == "ITL") and liq.level < current_price
                            distance = current_price - liq.level
                            if distance < best_distance
                                best_distance := distance
                                result := liq

    result

// ─────────────────────────────────────────────────────────────────────
// Check if there was a recent liquidity sweep
// ─────────────────────────────────────────────────────────────────────
check_recent_sweep(bool looking_for_bsl, int lookback_bars) =>
    bool result = false
    int arr_size = array.size(g_liquidity_array)

    if arr_size > 0
        for i = 0 to arr_size - 1
            if i < arr_size
                liq = array.get(g_liquidity_array, i)

                if liq.is_swept and bar_index - liq.swept_bar <= lookback_bars
                    if looking_for_bsl and (liq.liq_type == "EQH" or liq.liq_type == "ITH")
                        result := true
                        break
                    if not looking_for_bsl and (liq.liq_type == "EQL" or liq.liq_type == "ITL")
                        result := true
                        break

    result

// ─────────────────────────────────────────────────────────────────────
// Assess momentum quality of the inversion candle
// ─────────────────────────────────────────────────────────────────────
assess_momentum(float inv_open, float inv_high, float inv_low, float inv_close) =>
    string result = "neutral"

    candle_body = math.abs(inv_close - inv_open)
    candle_range = inv_high - inv_low

    if candle_range > 0 and not na(atr_value)
        body_ratio = candle_body / candle_range

        // Strong momentum: body >70% of range AND range > ATR
        if body_ratio > 0.7 and candle_range > atr_value
            result := "strong_no_chop"
        // Weak/choppy: small body (<30%) or very small range
        else if body_ratio < 0.3 or candle_range < atr_value * 0.5
            result := "weak_or_choppy"

    result

// ─────────────────────────────────────────────────────────────────────
// Calculate stop loss level
// ─────────────────────────────────────────────────────────────────────
calculate_stop_loss(bool is_bullish, float ifvg_bottom, float ifvg_top, float inv_close) =>
    float result = na

    // Default: Fail Stop - below/above the inversion candle body close
    if is_bullish
        // For bullish IFVG, stop below the zone
        result := ifvg_bottom
    else
        // For bearish IFVG, stop above the zone
        result := ifvg_top

    result

// ─────────────────────────────────────────────────────────────────────
// Full grading algorithm
// ─────────────────────────────────────────────────────────────────────
calculate_grade(bool has_sweep, bool has_delivery, string momentum, bool has_dol, bool in_optimal_zone, bool in_wrong_zone, bool fvg_singular) =>
    string result = "C"

    // ═══════════════════════════════════════════════════════════
    // STEP 1: MANDATORY CRITERIA → DETERMINE TIER
    // ═══════════════════════════════════════════════════════════

    // Must have clear DOL (target)
    if not has_dol
        result := "C"
    else
        string tier = "C"

        // Tier based on liquidity context
        if has_sweep and has_delivery
            tier := "A"
        else if has_sweep or has_delivery
            tier := "A"
        else
            tier := "B"

        // ═══════════════════════════════════════════════════════
        // STEP 2: QUALITY CRITERIA → DETERMINE MODIFIER
        // ═══════════════════════════════════════════════════════

        int quality_score = 0

        // Momentum (+1 / -1)
        if momentum == "strong_no_chop"
            quality_score := quality_score + 1
        else if momentum == "weak_or_choppy"
            quality_score := quality_score - 1

        // Premium/Discount (+1 / -1)
        if in_optimal_zone
            quality_score := quality_score + 1
        else if in_wrong_zone
            quality_score := quality_score - 1

        // FVG Clarity (+1 / -1)
        if fvg_singular
            quality_score := quality_score + 1
        else
            quality_score := quality_score - 1

        // Bonus: Both sweep AND delivery
        if has_sweep and has_delivery
            quality_score := quality_score + 1

        // ═══════════════════════════════════════════════════════
        // STEP 3: COMBINE TIER + MODIFIER
        // ═══════════════════════════════════════════════════════

        if tier == "A"
            if quality_score >= 3
                result := "A+"
            else if quality_score >= 1
                result := "A"
            else if quality_score >= -1
                result := "A-"
            else
                result := "B+"
        else if tier == "B"
            if quality_score >= 2
                result := "B+"
            else if quality_score >= 0
                result := "B"
            else
                result := "B-"
        else
            result := "C"

    result

// ══════════════════════════════════════════════════════════════════════
// SECTION 8: INVERSION DETECTION (Updated for Phase 2)
// ══════════════════════════════════════════════════════════════════════

check_inversions() =>
    int fvg_size = array.size(g_fvg_array)
    if barstate.isconfirmed and fvg_size > 0
        for i = fvg_size - 1 to 0
            if i >= 0 and i < array.size(g_fvg_array)  // Use fresh size check since array may be modified
                fvg = array.get(g_fvg_array, i)

                if fvg.status == "active"
                    fvg_age = bar_index - fvg.end_bar

                    if fvg_age >= 1
                        bool inverted = false

                        // Bullish FVG Inversion
                        if fvg.is_bullish
                            price_entered_zone = low <= fvg.top and low >= fvg.bottom
                            price_through_zone = low < fvg.bottom
                            body_closes_below = close < fvg.bottom

                            if (price_entered_zone or price_through_zone) and body_closes_below
                                inverted := true

                        // Bearish FVG Inversion
                        else
                            price_entered_zone = high >= fvg.bottom and high <= fvg.top
                            price_through_zone = high > fvg.top
                            body_closes_above = close > fvg.top

                            if (price_entered_zone or price_through_zone) and body_closes_above
                                inverted := true

                        // Process Inversion with Phase 2 enhancements
                        if inverted
                            fvg.status := "inverted"

                            // Delete FVG drawings
                            if not na(fvg.box_id)
                                box.delete(fvg.box_id)
                            if not na(fvg.label_id)
                                label.delete(fvg.label_id)

                            // IFVG direction is INVERTED
                            bool ifvg_is_bullish = not fvg.is_bullish

                            // ═══════════════════════════════════════════════════════════
                            // BE LEVEL - First swing point TO THE LEFT of the IFVG
                            // This is where you move your stop to breakeven (first target)
                            // ═══════════════════════════════════════════════════════════
                            float be_level = na
                            if ifvg_is_bullish
                                // Bullish IFVG (long): BE is first swing HIGH to the left
                                be_level := find_previous_swing_high(fvg.start_bar)
                                if na(be_level)
                                    be_level := fvg.top  // Fallback: use FVG top
                            else
                                // Bearish IFVG (short): BE is first swing LOW to the left
                                be_level := find_previous_swing_low(fvg.start_bar)
                                if na(be_level)
                                    be_level := fvg.bottom  // Fallback: use FVG bottom

                            // Final safety check - ensure BE is never na
                            if na(be_level)
                                be_level := ifvg_is_bullish ? fvg.top : fvg.bottom

                            // ═══════════════════════════════════════════════════════════
                            // SL LEVEL - Stop Loss placement (user configurable)
                            // Option 1: FVG Boundary (top for bearish, bottom for bullish)
                            // Option 2: Swing Stop (swing high for bearish, swing low for bullish)
                            // ═══════════════════════════════════════════════════════════
                            float sl_level = na
                            string sl_type_used = i_sl_type == "Swing Stop" ? "swing" : "fvg_boundary"

                            if ifvg_is_bullish
                                // Bullish IFVG (long): SL is BELOW entry
                                if i_sl_type == "Swing Stop"
                                    sl_level := find_previous_swing_low(fvg.start_bar)
                                    if na(sl_level)
                                        sl_level := fvg.bottom  // Fallback to FVG boundary
                                        sl_type_used := "fvg_boundary"
                                else
                                    sl_level := fvg.bottom
                            else
                                // Bearish IFVG (short): SL is ABOVE entry
                                if i_sl_type == "Swing Stop"
                                    sl_level := find_previous_swing_high(fvg.start_bar)
                                    if na(sl_level)
                                        sl_level := fvg.top  // Fallback to FVG boundary
                                        sl_type_used := "fvg_boundary"
                                else
                                    sl_level := fvg.top

                            // Final safety check - ensure SL is never na
                            if na(sl_level)
                                sl_level := ifvg_is_bullish ? fvg.bottom : fvg.top

                            // ═══════════════════════════════════════════════════════════
                            // ENTRY VALIDITY - Check if SL has been hit
                            // ═══════════════════════════════════════════════════════════
                            bool entry_valid = true
                            if ifvg_is_bullish
                                // Bullish: Invalid if price went BELOW SL level
                                entry_valid := low > sl_level
                            else
                                // Bearish: Invalid if price went ABOVE SL level
                                entry_valid := high < sl_level

                            // Find DOL (target)
                            Liquidity dol = find_dol(ifvg_is_bullish, close)
                            bool has_dol = not na(dol)

                            // Check for recent sweep
                            bool has_sweep = check_recent_sweep(not ifvg_is_bullish, 20)

                            // Assess momentum
                            string momentum = assess_momentum(open, high, low, close)

                            // Calculate grade
                            // Note: delivery from FVG requires more context, defaulting to false for now
                            bool has_delivery = false
                            bool in_optimal_zone = true  // Will be calculated in Phase 3 with PD zones
                            bool in_wrong_zone = false
                            bool fvg_singular = true  // Assuming singular for now

                            string grade = calculate_grade(
                                has_sweep, has_delivery, momentum, has_dol,
                                in_optimal_zone, in_wrong_zone, fvg_singular
                            )

                            // Create IFVG
                            new_ifvg = IFVG.new(
                                top = fvg.top,
                                bottom = fvg.bottom,
                                mid = fvg.mid,
                                start_bar = fvg.start_bar,
                                inversion_bar = bar_index,
                                inversion_close = close,
                                is_bullish = ifvg_is_bullish,
                                status = "inverted",
                                grade = grade,
                                entry_valid = entry_valid,
                                be_level = be_level,
                                be_status = entry_valid ? "intact" : "taken",
                                sl_level = sl_level,
                                sl_type = sl_type_used,
                                dol = dol,
                                has_sweep = has_sweep,
                                has_delivery = has_delivery,
                                momentum = momentum,
                                box_id = na,
                                label_id = na,
                                be_line_id = na,
                                sl_line_id = na,
                                entry_line_id = na,
                                entry_label_id = na
                            )

                            array.push(g_ifvg_array, new_ifvg)
                            array.remove(g_fvg_array, i)

// ══════════════════════════════════════════════════════════════════════
// SECTION 9: BE STATUS & MITIGATION DETECTION
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Update BE and SL status for all active IFVGs
// BE = First target (where to move stop to breakeven)
// SL = Stop loss level (invalidates entry if hit)
// ─────────────────────────────────────────────────────────────────────
update_be_status() =>
    int ifvg_size = array.size(g_ifvg_array)
    if barstate.isconfirmed and ifvg_size > 0
        for i = 0 to ifvg_size - 1
            if i < ifvg_size
                ifvg = array.get(g_ifvg_array, i)

                if ifvg.status == "inverted"
                    // Check if BE target has been reached (price moved in favor)
                    if ifvg.be_status == "intact"
                        if ifvg.is_bullish
                            // Bullish IFVG: BE reached if price hits BE level from below
                            if high >= ifvg.be_level
                                ifvg.be_status := "taken"
                        else
                            // Bearish IFVG: BE reached if price hits BE level from above
                            if low <= ifvg.be_level
                                ifvg.be_status := "taken"

                    // Check if SL has been hit (invalidates entry)
                    if ifvg.entry_valid
                        if ifvg.is_bullish
                            // Bullish: Invalid if price went BELOW SL level
                            if low < ifvg.sl_level
                                ifvg.entry_valid := false
                        else
                            // Bearish: Invalid if price went ABOVE SL level
                            if high > ifvg.sl_level
                                ifvg.entry_valid := false

// ─────────────────────────────────────────────────────────────────────
// Update DOL status for all active IFVGs
// If the DOL has been mitigated (swept or broken through), find a new valid DOL
// This ensures the dashboard always shows current, valid targets
// ─────────────────────────────────────────────────────────────────────
update_dol_status() =>
    int ifvg_size = array.size(g_ifvg_array)
    if barstate.isconfirmed and ifvg_size > 0
        for i = 0 to ifvg_size - 1
            if i < ifvg_size
                ifvg = array.get(g_ifvg_array, i)

                if ifvg.status == "inverted"
                    bool need_new_dol = false

                    // Check if current DOL is still valid
                    if not na(ifvg.dol)
                        // DOL is invalid if it has been swept OR broken through
                        if ifvg.dol.is_swept or not ifvg.dol.is_valid
                            need_new_dol := true
                    else
                        // No DOL set, try to find one
                        need_new_dol := true

                    // Find new DOL if needed
                    if need_new_dol
                        Liquidity new_dol = find_dol(ifvg.is_bullish, close)
                        ifvg.dol := new_dol

// ─────────────────────────────────────────────────────────────────────
// Check IFVG mitigations
// ─────────────────────────────────────────────────────────────────────
check_mitigations() =>
    int mitigation_count = 0
    int ifvg_size = array.size(g_ifvg_array)

    if barstate.isconfirmed and ifvg_size > 0
        for i = ifvg_size - 1 to 0
            if i >= 0 and i < array.size(g_ifvg_array)  // Use fresh size check since array may be modified
                ifvg = array.get(g_ifvg_array, i)

                if ifvg.status == "inverted"
                    bool mitigated = false

                    // Bullish IFVG Mitigation
                    if ifvg.is_bullish
                        if close < ifvg.bottom
                            mitigated := true
                    // Bearish IFVG Mitigation
                    else
                        if close > ifvg.top
                            mitigated := true

                    if mitigated
                        if not na(ifvg.box_id)
                            box.delete(ifvg.box_id)
                        if not na(ifvg.label_id)
                            label.delete(ifvg.label_id)
                        if not na(ifvg.be_line_id)
                            line.delete(ifvg.be_line_id)
                        if not na(ifvg.sl_line_id)
                            line.delete(ifvg.sl_line_id)
                        if not na(ifvg.entry_line_id)
                            line.delete(ifvg.entry_line_id)
                        if not na(ifvg.entry_label_id)
                            label.delete(ifvg.entry_label_id)

                        array.remove(g_ifvg_array, i)
                        mitigation_count += 1

    mitigation_count

// ══════════════════════════════════════════════════════════════════════
// SECTION 10: RENDERING
// ══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
// Render Active FVG Boxes
// ─────────────────────────────────────────────────────────────────────
render_fvg_boxes() =>
    int fvg_size = array.size(g_fvg_array)
    if i_show_active_fvg and fvg_size > 0
        for i = 0 to fvg_size - 1
            if i < fvg_size
                fvg = array.get(g_fvg_array, i)

                if fvg.status == "active"
                    if not na(fvg.box_id)
                        box.delete(fvg.box_id)
                    if not na(fvg.label_id)
                        label.delete(fvg.label_id)

                    bg_color = get_fvg_color(fvg.is_bullish)
                    border_color = get_border_color(fvg.is_bullish)
                    border_style = get_border_style(i_fvg_border_style)
                    right_edge = bar_index + i_extend_bars

                    fvg.box_id := box.new(
                        left = fvg.start_bar,
                        top = fvg.top,
                        right = right_edge,
                        bottom = fvg.bottom,
                        bgcolor = bg_color,
                        border_color = border_color,
                        border_width = i_fvg_border_width,
                        border_style = border_style
                    )

                    if i_show_labels
                        label_text = fvg.is_bullish ? "FVG ▲" : "FVG ▼"
                        fvg.label_id := label.new(
                            x = right_edge - 2,
                            y = fvg.bottom,
                            text = label_text,
                            style = label.style_none,
                            color = color.new(color.black, 100),
                            textcolor = border_color,
                            size = get_label_size(),
                            textalign = text.align_right,
                            yloc = yloc.price
                        )

// ─────────────────────────────────────────────────────────────────────
// Render IFVG Boxes (Phase 2: with grade and BE)
// ─────────────────────────────────────────────────────────────────────
render_ifvg_boxes() =>
    int ifvg_size = array.size(g_ifvg_array)
    if ifvg_size > 0
        // Count how many IFVGs have been displayed (from newest to oldest)
        int displayed_count = 0

        // Process from newest to oldest (end of array to start)
        for i = ifvg_size - 1 to 0
            if i >= 0 and i < ifvg_size
                ifvg = array.get(g_ifvg_array, i)

                // Always delete old drawings first
                if not na(ifvg.box_id)
                    box.delete(ifvg.box_id)
                    ifvg.box_id := na
                if not na(ifvg.label_id)
                    label.delete(ifvg.label_id)
                    ifvg.label_id := na
                if not na(ifvg.be_line_id)
                    line.delete(ifvg.be_line_id)
                    ifvg.be_line_id := na
                if not na(ifvg.sl_line_id)
                    line.delete(ifvg.sl_line_id)
                    ifvg.sl_line_id := na
                if not na(ifvg.entry_line_id)
                    line.delete(ifvg.entry_line_id)
                    ifvg.entry_line_id := na
                if not na(ifvg.entry_label_id)
                    label.delete(ifvg.entry_label_id)
                    ifvg.entry_label_id := na

                // Check HTF bias alignment (Phase 3)
                bool htf_aligned = true
                if i_enable_htf and i_htf_filter_ltf
                    // Calculate bias inline from HTF IFVG arrays
                    string htf1_b = "neutral"
                    string htf2_b = "neutral"
                    if array.size(g_htf_ifvg_array) > 0
                        IFVG htf1_r = array.get(g_htf_ifvg_array, array.size(g_htf_ifvg_array) - 1)
                        htf1_b := htf1_r.status == "inverted" ? (htf1_r.is_bullish ? "bullish" : "bearish") : "neutral"
                    if array.size(g_htf2_ifvg_array) > 0
                        IFVG htf2_r = array.get(g_htf2_ifvg_array, array.size(g_htf2_ifvg_array) - 1)
                        htf2_b := htf2_r.status == "inverted" ? (htf2_r.is_bullish ? "bullish" : "bearish") : "neutral"
                    string combined_bias = htf1_b != "neutral" ? htf1_b : htf2_b
                    if combined_bias != "neutral"
                        // Filter: only show LTF setups that match HTF bias
                        htf_aligned := (combined_bias == "bullish" and ifvg.is_bullish) or
                                      (combined_bias == "bearish" and not ifvg.is_bullish)

                // Only render if: enabled, inverted status, meets grade, HTF aligned, and under display limit
                bool should_display = i_show_ifvg and ifvg.status == "inverted" and
                                     grade_meets_minimum(ifvg.grade, i_min_grade_display) and
                                     htf_aligned and
                                     displayed_count < i_max_recent_display

                if should_display
                    displayed_count += 1

                    // IFVG box: translucent gray with NO borders
                    ifvg_bg_color = color.new(i_ifvg_box_color, i_ifvg_box_opacity)
                    right_edge = bar_index + i_extend_bars

                    // Draw IFVG box (gray, no borders)
                    ifvg.box_id := box.new(
                        left = ifvg.start_bar,
                        top = ifvg.top,
                        right = right_edge,
                        bottom = ifvg.bottom,
                        bgcolor = ifvg_bg_color,
                        border_color = color.new(color.gray, 100),  // Fully transparent border
                        border_width = 0,
                        border_style = line.style_solid
                    )

                    // Draw tiny "IFVG" label at bottom-right corner of box
                    if i_show_labels
                        ifvg.label_id := label.new(
                            x = right_edge - 2,
                            y = ifvg.bottom,
                            text = "IFVG",
                            style = label.style_none,
                            color = color.new(color.black, 100),
                            textcolor = color.new(color.gray, 30),  // Subtle gray text
                            size = size.tiny,
                            textalign = text.align_right,
                            yloc = yloc.price
                        )

                    // ═══════════════════════════════════════════════════════════
                    // Draw SL line (Stop Loss - ABOVE for bearish, BELOW for bullish)
                    // Drawn FIRST so BE line appears on top
                    // ═══════════════════════════════════════════════════════════
                    if i_show_sl_level
                        float sl_draw_level = ifvg.sl_level
                        if na(sl_draw_level)
                            // Fallback: use FVG boundary
                            sl_draw_level := ifvg.is_bullish ? ifvg.bottom : ifvg.top

                        if not na(sl_draw_level)
                            sl_line_color = ifvg.entry_valid ? i_sl_color : color.new(i_sl_color, 60)
                            sl_line_style = line.style_solid

                            ifvg.sl_line_id := line.new(
                                x1 = ifvg.start_bar,
                                y1 = sl_draw_level,
                                x2 = right_edge,
                                y2 = sl_draw_level,
                                color = sl_line_color,
                                style = sl_line_style,
                                width = 2
                            )

                    // ═══════════════════════════════════════════════════════════
                    // Draw BE line (Break-Even target - BELOW for bearish, ABOVE for bullish)
                    // This is the first swing target where you move stop to breakeven
                    // ═══════════════════════════════════════════════════════════
                    if i_show_be_level
                        float be_draw_level = ifvg.be_level
                        if na(be_draw_level)
                            // Fallback: use FVG boundary
                            be_draw_level := ifvg.is_bullish ? ifvg.top : ifvg.bottom

                        if not na(be_draw_level)
                            be_line_color = ifvg.be_status == "intact" ? i_be_color : color.new(i_be_color, 60)
                            be_line_style = ifvg.be_status == "intact" ? line.style_dashed : line.style_dotted

                            ifvg.be_line_id := line.new(
                                x1 = ifvg.start_bar,
                                y1 = be_draw_level,
                                x2 = right_edge,
                                y2 = be_draw_level,
                                color = be_line_color,
                                style = be_line_style,
                                width = 2
                            )

                    // ═══════════════════════════════════════════════════════════
                    // Draw Entry Line at inversion candle close
                    // Shows Grade + Direction (e.g., "A+ BUY" or "B- SELL")
                    // ═══════════════════════════════════════════════════════════
                    if i_show_entry_line
                        float entry_level = ifvg.inversion_close
                        if not na(entry_level)
                            // Entry line color based on direction
                            entry_line_color = ifvg.is_bullish ? i_entry_color_bull : i_entry_color_bear

                            // Draw entry line
                            ifvg.entry_line_id := line.new(
                                x1 = ifvg.inversion_bar,
                                y1 = entry_level,
                                x2 = right_edge,
                                y2 = entry_level,
                                color = entry_line_color,
                                style = line.style_solid,
                                width = 2
                            )

                            // Build tooltip with grade breakdown
                            sweep_check = ifvg.has_sweep ? "☑" : "☐"
                            delivery_check = ifvg.has_delivery ? "☑" : "☐"
                            momentum_text = ifvg.momentum == "strong_no_chop" ? "Strong" : (ifvg.momentum == "weak_or_choppy" ? "Weak" : "Neutral")
                            momentum_check = ifvg.momentum == "strong_no_chop" ? "☑" : "☐"
                            dol_text = not na(ifvg.dol) ? (ifvg.dol.liq_type + " @ " + str.tostring(ifvg.dol.level, format.mintick)) : "None"
                            dol_check = not na(ifvg.dol) ? "☑" : "☐"
                            entry_status = ifvg.entry_valid ? "VALID" : "INVALID"

                            tooltip_text = "Grade: " + ifvg.grade + "\n" +
                                          "─────────────\n" +
                                          sweep_check + " Sweep\n" +
                                          delivery_check + " PDA Delivery\n" +
                                          momentum_check + " Momentum: " + momentum_text + "\n" +
                                          dol_check + " DOL: " + dol_text + "\n" +
                                          "─────────────\n" +
                                          "Entry: " + entry_status

                            // Entry line label: Grade + Direction (positioned on top right of line)
                            direction_text = ifvg.is_bullish ? "BUY" : "SELL"
                            entry_label_text = ifvg.grade + " " + direction_text

                            ifvg.entry_label_id := label.new(
                                x = right_edge,
                                y = entry_level,
                                text = entry_label_text,
                                style = label.style_none,
                                color = color.new(color.black, 100),
                                textcolor = entry_line_color,
                                size = size.small,
                                textalign = text.align_right,
                                yloc = yloc.price,
                                tooltip = tooltip_text
                            )

// ─────────────────────────────────────────────────────────────────────
// Render HTF FVG Boxes (Phase 3)
// ─────────────────────────────────────────────────────────────────────
render_htf_fvg_boxes(array<FVG> arr, string tf_label) =>
    if i_enable_htf and i_show_htf_fvg
        int arr_size = array.size(arr)
        if arr_size > 0
            for i = 0 to arr_size - 1
                if i < array.size(arr)
                    fvg = array.get(arr, i)

                    if fvg.status == "active"
                        // Delete old drawings
                        if not na(fvg.box_id)
                            box.delete(fvg.box_id)
                        if not na(fvg.label_id)
                            label.delete(fvg.label_id)

                        // HTF boxes: same colors but thicker borders
                        base_color = fvg.is_bullish ? i_bullish_color : i_bearish_color
                        bg_color = color.new(base_color, i_htf_box_opacity)
                        border_color = base_color
                        right_edge = bar_index + i_extend_bars
                        // Clamp left edge to prevent "bar index too far" error (max_bars_back = 500)
                        int left_edge = math.max(fvg.start_bar, bar_index - 400)

                        fvg.box_id := box.new(
                            left = left_edge,
                            top = fvg.top,
                            right = right_edge,
                            bottom = fvg.bottom,
                            bgcolor = bg_color,
                            border_color = border_color,
                            border_width = i_htf_border_width,
                            border_style = line.style_solid
                        )

                        // Label with timeframe indicator
                        if i_show_labels
                            direction_arrow = fvg.is_bullish ? " ▲" : " ▼"
                            label_text = "[" + tf_label + "] FVG" + direction_arrow

                            fvg.label_id := label.new(
                                x = right_edge - 2,
                                y = fvg.is_bullish ? fvg.bottom : fvg.top,
                                text = label_text,
                                style = label.style_none,
                                color = color.new(color.black, 100),
                                textcolor = border_color,
                                size = size.small,
                                textalign = text.align_right,
                                yloc = yloc.price
                            )

// ─────────────────────────────────────────────────────────────────────
// Render HTF IFVG Boxes (Phase 3)
// ─────────────────────────────────────────────────────────────────────
render_htf_ifvg_boxes(array<IFVG> arr, string tf_label) =>
    if i_enable_htf and i_show_htf_ifvg
        int arr_size = array.size(arr)
        if arr_size > 0
            for i = 0 to arr_size - 1
                if i < array.size(arr)
                    ifvg = array.get(arr, i)

                    if ifvg.status == "inverted"
                        // Delete old drawings
                        if not na(ifvg.box_id)
                            box.delete(ifvg.box_id)
                        if not na(ifvg.label_id)
                            label.delete(ifvg.label_id)

                        // HTF IFVG boxes: use gray with dashed thick border
                        bg_color = color.new(color.gray, i_htf_box_opacity)
                        border_color = ifvg.is_bullish ? i_bullish_color : i_bearish_color
                        right_edge = bar_index + i_extend_bars
                        // Clamp left edge to prevent "bar index too far" error (max_bars_back = 500)
                        int left_edge = math.max(ifvg.start_bar, bar_index - 400)

                        ifvg.box_id := box.new(
                            left = left_edge,
                            top = ifvg.top,
                            right = right_edge,
                            bottom = ifvg.bottom,
                            bgcolor = bg_color,
                            border_color = border_color,
                            border_width = i_htf_border_width,
                            border_style = line.style_dashed
                        )

                        // Label with timeframe and direction
                        if i_show_labels
                            direction_text = ifvg.is_bullish ? "LONG" : "SHORT"
                            label_text = "[" + tf_label + "] IFVG " + direction_text

                            ifvg.label_id := label.new(
                                x = right_edge - 2,
                                y = ifvg.bottom,
                                text = label_text,
                                style = label.style_none,
                                color = color.new(color.black, 100),
                                textcolor = border_color,
                                size = size.small,
                                textalign = text.align_right,
                                yloc = yloc.price
                            )

// ─────────────────────────────────────────────────────────────────────
// Get timeframe display label
// ─────────────────────────────────────────────────────────────────────
get_tf_label(string tf) =>
    string result = tf
    if tf == "1"
        result := "1m"
    else if tf == "3"
        result := "3m"
    else if tf == "5"
        result := "5m"
    else if tf == "15"
        result := "15m"
    else if tf == "30"
        result := "30m"
    else if tf == "60"
        result := "1H"
    else if tf == "120"
        result := "2H"
    else if tf == "240"
        result := "4H"
    result

// ─────────────────────────────────────────────────────────────────────
// Render Liquidity Lines (Phase 2 - Enhanced with quality indicators)
// ─────────────────────────────────────────────────────────────────────
render_liquidity_lines() =>
    int liq_size = array.size(g_liquidity_array)
    if liq_size > 0
        for i = 0 to liq_size - 1
            if i < liq_size
                liq = array.get(g_liquidity_array, i)

                // Skip if feature is disabled (delete drawings first)
                if (liq.liq_type == "EQH" or liq.liq_type == "EQL") and not i_show_eqh_eql
                    if not na(liq.line_id)
                        line.delete(liq.line_id)
                        liq.line_id := na
                    if not na(liq.label_id)
                        label.delete(liq.label_id)
                        liq.label_id := na
                    continue
                if (liq.liq_type == "ITH" or liq.liq_type == "ITL") and not i_show_ith_itl
                    if not na(liq.line_id)
                        line.delete(liq.line_id)
                        liq.line_id := na
                    if not na(liq.label_id)
                        label.delete(liq.label_id)
                        liq.label_id := na
                    continue

                // Skip mitigated EQL/EQH (swept OR broken through) if user doesn't want to see them
                // IMPORTANT: Delete drawings before skipping to remove them from chart
                if (liq.is_swept or not liq.is_valid) and not i_show_swept_eqhl
                    if liq.liq_type == "EQH" or liq.liq_type == "EQL"
                        if not na(liq.line_id)
                            line.delete(liq.line_id)
                            liq.line_id := na
                        if not na(liq.label_id)
                            label.delete(liq.label_id)
                            liq.label_id := na
                        continue

                // Skip relative EQL/EQH if user only wants to see perfect ones
                // NOTE: Data is still collected for grading algorithms, only rendering is filtered
                if i_show_perfect_only and liq.quality == "relative"
                    if liq.liq_type == "EQH" or liq.liq_type == "EQL"
                        if not na(liq.line_id)
                            line.delete(liq.line_id)
                            liq.line_id := na
                        if not na(liq.label_id)
                            label.delete(liq.label_id)
                            liq.label_id := na
                        continue

                // Delete old drawings (for items that will be redrawn)
                if not na(liq.line_id)
                    line.delete(liq.line_id)
                if not na(liq.label_id)
                    label.delete(liq.label_id)

                // Determine color and style based on type, quality, and status
                line_color = color.gray
                line_style = line.style_solid
                int line_width = 1

                if liq.liq_type == "EQH" or liq.liq_type == "EQL"
                    // Base color depends on quality
                    if liq.quality == "perfect"
                        line_color := color.new(#FF6600, 0)  // Bright orange for perfect
                        line_width := 2
                    else
                        line_color := i_liq_color  // Standard orange for relative

                    // Modify for swept status
                    if liq.is_swept
                        line_color := color.new(color.gray, 50)  // Gray out swept
                        line_style := line.style_dotted
                    else if not liq.is_valid
                        line_color := color.new(color.gray, 70)  // Faded if broken through
                        line_style := line.style_dotted
                    else
                        line_style := line.style_solid

                else if liq.liq_type == "ITH" or liq.liq_type == "ITL"
                    line_color := liq.is_swept ? color.new(i_ithl_color, 70) : i_ithl_color
                    line_style := line.style_dashed

                right_edge = bar_index + i_extend_bars

                // Draw line
                liq.line_id := line.new(
                    x1 = liq.bar_idx,
                    y1 = liq.level,
                    x2 = right_edge,
                    y2 = liq.level,
                    color = line_color,
                    style = line_style,
                    width = line_width
                )

                // Draw label with enhanced info
                if i_show_labels
                    label_text = liq.liq_type

                    if liq.liq_type == "EQH" or liq.liq_type == "EQL"
                        // Build label based on quality:
                        // Perfect: "EQL★ (2)" or "EQH★ (3)"
                        // Relative: "R.EQL (2)" or "R.EQH (3)"
                        if liq.quality == "perfect"
                            label_text := liq.liq_type + "★ (" + str.tostring(liq.touch_count) + ")"
                        else if liq.quality == "relative"
                            label_text := "R." + liq.liq_type + " (" + str.tostring(liq.touch_count) + ")"
                        else
                            label_text := liq.liq_type + " (" + str.tostring(liq.touch_count) + ")"

                    // Add status indicator
                    if liq.is_swept
                        label_text := label_text + " ✗"
                    else if not liq.is_valid
                        label_text := label_text + " ⊘"  // Broken through but not swept

                    liq.label_id := label.new(
                        x = right_edge,
                        y = liq.level,
                        text = label_text,
                        style = label.style_none,
                        color = color.new(color.black, 100),
                        textcolor = line_color,
                        size = size.tiny,
                        textalign = text.align_left,
                        yloc = yloc.price
                    )

// ─────────────────────────────────────────────────────────────────────
// Find Most Recent IFVG for dashboard
// ─────────────────────────────────────────────────────────────────────
find_most_recent_ifvg() =>
    IFVG recent = na
    int arr_size = array.size(g_ifvg_array)

    if arr_size > 0
        // Get the most recent (last) IFVG that is still inverted (not mitigated)
        for i = arr_size - 1 to 0
            if i >= 0 and i < arr_size
                ifvg = array.get(g_ifvg_array, i)
                if ifvg.status == "inverted"
                    recent := ifvg
                    break

    recent

// ══════════════════════════════════════════════════════════════════════
// SECTION 11: DASHBOARD (Phase 3 Enhanced)
// ══════════════════════════════════════════════════════════════════════

var table dashboard = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 80), border_width=1, border_color=color.gray)

render_dashboard(IFVG latest_ifvg) =>
    if barstate.islast
        // Row 0: Title
        table.cell(dashboard, 0, 0, "IFVG PRO v3.0", text_color=color.white, text_size=size.normal, text_halign=text.align_left)
        table.cell(dashboard, 1, 0, "", text_color=color.white, text_size=size.normal)

        // Row 1: Active FVGs
        table.cell(dashboard, 0, 1, "Active FVGs:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 1, str.tostring(array.size(g_fvg_array)), text_color=color.white, text_size=size.small, text_halign=text.align_right)

        // Row 2: Active IFVGs
        table.cell(dashboard, 0, 2, "Active IFVGs:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 2, str.tostring(array.size(g_ifvg_array)), text_color=color.white, text_size=size.small, text_halign=text.align_right)

        // Row 3: Liquidity Levels
        table.cell(dashboard, 0, 3, "Liquidity:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 3, str.tostring(array.size(g_liquidity_array)), text_color=color.white, text_size=size.small, text_halign=text.align_right)

        // Row 4: Divider
        table.cell(dashboard, 0, 4, "─────────", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 4, "────", text_color=color.gray, text_size=size.small, text_halign=text.align_right)

        // Row 5: Latest Setup
        latest_grade = not na(latest_ifvg) ? latest_ifvg.grade : "-"
        latest_color = not na(latest_ifvg) ? grade_to_color(latest_ifvg.grade) : color.gray
        table.cell(dashboard, 0, 5, "Latest Setup:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 5, latest_grade + " IFVG", text_color=latest_color, text_size=size.small, text_halign=text.align_right)

        // Row 6: Entry Status
        entry_text = not na(latest_ifvg) ? (latest_ifvg.entry_valid ? "VALID" : "INVALID") : "-"
        entry_color = not na(latest_ifvg) and latest_ifvg.entry_valid ? color.green : color.red
        if na(latest_ifvg)
            entry_color := color.gray
        table.cell(dashboard, 0, 6, "Entry:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 6, entry_text, text_color=entry_color, text_size=size.small, text_halign=text.align_right)

        // Row 7: DOL Target
        dol_text = "-"
        if not na(latest_ifvg) and not na(latest_ifvg.dol)
            dol_text := latest_ifvg.dol.liq_type + " @ " + str.tostring(latest_ifvg.dol.level, format.mintick)
        table.cell(dashboard, 0, 7, "DOL:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 7, dol_text, text_color=color.white, text_size=size.small, text_halign=text.align_right)

        // Row 8: HTF Bias (Phase 3)
        string htf_bias_text = "-"
        color htf_bias_color = color.gray
        if i_enable_htf
            // Calculate bias inline from HTF IFVG arrays
            string dash_htf1_b = "neutral"
            string dash_htf2_b = "neutral"
            if array.size(g_htf_ifvg_array) > 0
                IFVG dash_htf1_r = array.get(g_htf_ifvg_array, array.size(g_htf_ifvg_array) - 1)
                dash_htf1_b := dash_htf1_r.status == "inverted" ? (dash_htf1_r.is_bullish ? "bullish" : "bearish") : "neutral"
            if array.size(g_htf2_ifvg_array) > 0
                IFVG dash_htf2_r = array.get(g_htf2_ifvg_array, array.size(g_htf2_ifvg_array) - 1)
                dash_htf2_b := dash_htf2_r.status == "inverted" ? (dash_htf2_r.is_bullish ? "bullish" : "bearish") : "neutral"
            string combined_bias = dash_htf1_b != "neutral" ? dash_htf1_b : dash_htf2_b
            htf_bias_text := str.upper(combined_bias)
            if combined_bias == "bullish"
                htf_bias_color := color.green
            else if combined_bias == "bearish"
                htf_bias_color := color.red
        table.cell(dashboard, 0, 8, "HTF Bias:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 8, htf_bias_text, text_color=htf_bias_color, text_size=size.small, text_halign=text.align_right)

        // Row 9: HTF TF Display
        string htf_tf_text = "-"
        if i_enable_htf
            htf_tf_text := get_tf_label(i_htf_timeframe)
            if i_htf_timeframe_2 != i_htf_timeframe
                htf_tf_text := htf_tf_text + " / " + get_tf_label(i_htf_timeframe_2)
        table.cell(dashboard, 0, 9, "HTF:", text_color=color.gray, text_size=size.small, text_halign=text.align_left)
        table.cell(dashboard, 1, 9, htf_tf_text, text_color=color.white, text_size=size.small, text_halign=text.align_right)

// ══════════════════════════════════════════════════════════════════════
// SECTION 12: MAIN EXECUTION LOOP
// ══════════════════════════════════════════════════════════════════════

if i_show_indicator
    // ─────────────────────────────────────────────────────────────────
    // Step 1: Detect swing points for liquidity
    // ─────────────────────────────────────────────────────────────────
    detect_swing_points()

    // ─────────────────────────────────────────────────────────────────
    // Step 2: Check for EQH/EQL formations
    // ─────────────────────────────────────────────────────────────────
    check_equal_highs()
    check_equal_lows()
    create_internal_levels()
    cleanup_liquidity_array()

    // ─────────────────────────────────────────────────────────────────
    // Step 3: Check for liquidity sweeps
    // ─────────────────────────────────────────────────────────────────
    check_liquidity_sweeps()

    // ─────────────────────────────────────────────────────────────────
    // Step 4: Detect new LTF FVGs
    // ─────────────────────────────────────────────────────────────────
    new_fvg = detect_fvg()
    if not na(new_fvg)
        array.push(g_fvg_array, new_fvg)
        cleanup_fvg_array()

    // ─────────────────────────────────────────────────────────────────
    // Step 4B: Detect HTF FVGs (Phase 3)
    // ─────────────────────────────────────────────────────────────────
    if i_enable_htf
        // HTF 1 FVG Detection
        htf1_fvg = detect_htf_fvg(i_htf_timeframe, htf_high, htf_low, htf_high_2, htf_low_2, htf_atr, htf_bar_changed)
        if not na(htf1_fvg) and not htf_fvg_exists(g_htf_fvg_array, htf1_fvg.top, htf1_fvg.bottom, htf1_fvg.is_bullish)
            array.push(g_htf_fvg_array, htf1_fvg)
            cleanup_htf_fvg_array(g_htf_fvg_array, i_max_fvgs)

        // HTF 2 FVG Detection (only if different from HTF 1)
        if i_htf_timeframe_2 != i_htf_timeframe
            htf2_fvg = detect_htf_fvg(i_htf_timeframe_2, htf2_high, htf2_low, htf2_high_2, htf2_low_2, htf2_atr, htf2_bar_changed)
            if not na(htf2_fvg) and not htf_fvg_exists(g_htf2_fvg_array, htf2_fvg.top, htf2_fvg.bottom, htf2_fvg.is_bullish)
                array.push(g_htf2_fvg_array, htf2_fvg)
                cleanup_htf_fvg_array(g_htf2_fvg_array, i_max_fvgs)

    // ─────────────────────────────────────────────────────────────────
    // Step 5: Check for LTF inversions (FVG → IFVG)
    // ─────────────────────────────────────────────────────────────────
    check_inversions()
    cleanup_ifvg_array()

    // ─────────────────────────────────────────────────────────────────
    // Step 5B: Check for HTF inversions (Phase 3)
    // ─────────────────────────────────────────────────────────────────
    if i_enable_htf
        check_htf_inversions(g_htf_fvg_array, g_htf_ifvg_array, htf_close, i_htf_timeframe)
        cleanup_htf_ifvg_array(g_htf_ifvg_array, i_max_ifvgs)

        if i_htf_timeframe_2 != i_htf_timeframe
            check_htf_inversions(g_htf2_fvg_array, g_htf2_ifvg_array, htf2_close, i_htf_timeframe_2)
            cleanup_htf_ifvg_array(g_htf2_ifvg_array, i_max_ifvgs)

    // ─────────────────────────────────────────────────────────────────
    // Step 5C: Check HTF IFVG mitigations (Phase 3)
    // ─────────────────────────────────────────────────────────────────
    if i_enable_htf
        check_htf_mitigations(g_htf_ifvg_array, htf_close)
        if i_htf_timeframe_2 != i_htf_timeframe
            check_htf_mitigations(g_htf2_ifvg_array, htf2_close)

    // ─────────────────────────────────────────────────────────────────
    // Step 6: Update BE status
    // ─────────────────────────────────────────────────────────────────
    update_be_status()

    // ─────────────────────────────────────────────────────────────────
    // Step 6.5: Update DOL status (refresh stale/mitigated DOLs)
    // ─────────────────────────────────────────────────────────────────
    update_dol_status()

    // ─────────────────────────────────────────────────────────────────
    // Step 7: Check for mitigations (IFVG removal)
    // ─────────────────────────────────────────────────────────────────
    check_mitigations()

    // ─────────────────────────────────────────────────────────────────
    // Step 8: Find best IFVG for dashboard
    // ─────────────────────────────────────────────────────────────────
    IFVG current_latest_ifvg = find_most_recent_ifvg()

    // ─────────────────────────────────────────────────────────────────
    // Step 9: Render all elements
    // ─────────────────────────────────────────────────────────────────
    render_fvg_boxes()
    render_ifvg_boxes()

    // ─────────────────────────────────────────────────────────────────
    // Step 9B: Render HTF elements (Phase 3)
    // ─────────────────────────────────────────────────────────────────
    if i_enable_htf
        string htf1_label = get_tf_label(i_htf_timeframe)
        string htf2_label = get_tf_label(i_htf_timeframe_2)

        render_htf_fvg_boxes(g_htf_fvg_array, htf1_label)
        render_htf_ifvg_boxes(g_htf_ifvg_array, htf1_label)

        if i_htf_timeframe_2 != i_htf_timeframe
            render_htf_fvg_boxes(g_htf2_fvg_array, htf2_label)
            render_htf_ifvg_boxes(g_htf2_ifvg_array, htf2_label)

    render_liquidity_lines()
    render_dashboard(current_latest_ifvg)
